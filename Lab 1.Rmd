---
title: "Lab 1"
author: "Óscar Agüero Rodriguez"
date: "30/8/2020"
output: 
  github_document:
    toc: TRUE
    toc_depth: 2
---

Paquetes a utilizar

```{r}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(sf))
suppressPackageStartupMessages(library(mapview))
suppressPackageStartupMessages(library(abind))
suppressPackageStartupMessages(library(stars))
suppressPackageStartupMessages(library(RSQLite))
suppressPackageStartupMessages(library(spacetime))
suppressPackageStartupMessages(library(xts))
suppressPackageStartupMessages(library(starsdata))
suppressPackageStartupMessages(library(spData))
suppressPackageStartupMessages(library(spDataLarge))
suppressPackageStartupMessages(library(units))
suppressPackageStartupMessages(library(cubelyr))
suppressPackageStartupMessages(library(tmap))
```

# 1.3 Exercises

## 1.3.1 

Read the shapefile storms_xyz_feature from the shape directory in the sf package

```{r}
tst = st_read(system.file("shape/storms_xyz_feature.shp", package="sf"), quiet = TRUE)
class(st_geometry(tst))
class(st_geometry(tst)[[1]])
```


## 1.3.2 

Copy this file to another directory on your computer, and read it from there (note: a shapefile consists of more than one file!)

```{r}
setwd("~/Estadística/Spacial Stats/Storms_xyz")
tst1 <- st_read("storms_xyz_feature.shp")
```

## 1.3.3 

How many features does this dataset contain?

```{r}
tst1
```

Tiene 71 features

## 1.3.4 

Plot the dataset, with axes = TRUE (hint: before plotting, pipe through st_zm to drop Z and M coordinates; more about this in chapter 3).

```{r}
system.file("shape/storms_xyz_feature.shp", package="sf") %>%
  read_sf() %>%
  st_zm() %>% 
  plot(graticule = TRUE, axes = TRUE)

```

## 1.3.5 

Before plotting, pipe the dataset through st_set_crs(4326). What is different in the plot obtained?

```{r}
system.file("shape/storms_xyz_feature.shp", package="sf") %>%
  read_sf() %>%
  st_zm() %>% 
  st_set_crs(4326) %>% 
  plot(graticule = TRUE, axes = TRUE)
```

La diferencia observada esta principalmente en las coordenadas del plano, en el segunndo plano se pueden ver la dirección de los grados en los margenes.

# 2.6 Exercices

## 2.6.1 

Convert $(x , y)$ point (10,2), (-10,-2), (10,2) and (0,10) to polar coordinates

Coordenada (10,2)

```{r}
x1 <- 10; y1 <- 2
c1 <- sqrt(x1^2 + y1^2)
p1 <- atan(y1/x1)
copor1 <- cbind(c1, p1);copor1

```

Coordenada (-10,-2)

```{r}
x2 <- -10; y2 <- -2
c2 <- sqrt(x2^2 + y2^2)
p2 <- atan(y2/x2)
copor2 <- cbind(c2, p2);copor2
```

Coordenada (10,-2)

```{r}
x3 <- 10; y3 <- -2
c3 <- sqrt(x3^2 + y3^2)
p3 <- atan(y3/x3)
copor3 <- cbind(c3, p3);copor3
```

Coordenada (0,10)

```{r}
x4 <- 0; y4 <- 10
c4 <- sqrt(x4^2 + y4^2)
p4 <- atan(y4/x4)
copor4 <- cbind(c4, p4);copor4

```

## 2.6.2

Convert the polar $(r,\phi)$ points (10, 45°), (0,100°) and (5,359°) to cartesian coordinates

```{r}
r1 <- 10;phi1 <- 45
r2 <- 0; phi2 <- 100
r3 <- 5; phi3 <- 359

x_1 <- r1*cos(phi1)
y_1 <- r1*sin(phi1)

x_2 <- r2*cos(phi2)
y_2 <- r2*sin(phi2)

x_3 <- r3*cos(phi3)
y_3 <- r3*sin(phi3)

cc1 <- round(cbind(x_1,y_1),1)
cc2 <- round(cbind(x_2,y_2),1)
cc3 <- round(cbind(x_3,y_3),1)

resumen <- cbind(cc1, cc2, cc3)
resumen

```

## 2.6.3

Assuming the Earth is a sphere with a radius of 6371 km, compute for $(\lambda, \phi)$ points the great circle distance between (10,10) and (11,10), between (10,80) and (11,80), between (10,10) and (11,10) and between (10,80) and (11,81) (units: degree): What the distance units?

Para dos punto $p_1 = (\lambda_1, \phi_1)$ y $p_2 = (\lambda_2, \phi_2)$, donde $p_1$ y $p_2$ deben ser calculados en radianes, se debe convertir primero los grados a Radianes.

Eso se realiza entendiendo que:

$$1° = \frac{\pi}{180}$$

Conversión

```{r}
lambda1 <- 10*(pi/180)
theta1 <- 10*(pi/180)
lambda2 <- 11*(pi/180)
theta2 <- 10*(pi/180)

lambda3 <- 10*(pi/180)
theta3 <- 80*(pi/180)
lambda4 <- 11*(pi/180)
theta4 <- 80*(pi/180)

lambda5 <- 10*(pi/180)
theta5 <- 10*(pi/180)
lambda6 <- 10*(pi/180)
theta6 <- 11*(pi/180)

lambda7 <- 10*(pi/180)
theta7 <- 80*(pi/180)
lambda8 <- 10*(pi/180)
theta8 <- 81*(pi/180)

r <- 6371
```

Para obtener la distancia además, se debe aplicar la siguiente formulas en esta secuencia

$$\theta_{12} = arccos(sin(\theta_1)*sin(\theta_2)+cos(\theta_1)*cos(\theta_2)cos(|\lambda_1 - \lambda_2|))$$

$$S_{12} = r*\theta_{12}$$

Distancia (1,2) entre arco (10,10) y (11,10)

```{r}
theta12 <- acos(sin(theta1)*sin(theta2)+cos(theta1)*cos(theta2)*cos(abs(lambda1-lambda2)))
s12 <- r*theta12
s_12g <- (s12*180)/pi 

s12;s_12g

```

Distancia (3,4) entre arco (10,80) y (11,80)

```{r}
theta34 <- acos(sin(theta3)*sin(theta4)+cos(theta3)*cos(theta4)*cos(abs(lambda3-lambda4)))
s34 <- r*theta34
s_34g <- (s34*180)/pi 

s34;s_34g

```

Distancia (5,6) entre arco (10,10) y (10,11)

```{r}
theta56 <- acos(sin(theta5)*sin(theta6)+cos(theta5)*cos(theta6)*cos(abs(lambda5-lambda6)))
s56 <- r*theta56
s_56g <- (s56*180)/pi 

s56;s_56g
```

Distancia (7,8) entre arco (10,80) y (10,81)

```{r}
theta78 <- acos(sin(theta7)*sin(theta8)+cos(theta7)*cos(theta8)*cos(abs(lambda7-lambda8)))
s78 <- r*theta78
s_78g <- (s78*180)/pi 

s78;s_78g
```

# 4.4 Exercises 

## 4.4.1

NDVI, normalized differenced vegetation index, is computed as (NIR-R)/(NIR+R), with NIR the near infrared and R the red band. Read the L7_ETMs.tif file into object x, and distribute the band dimensions over attributes by split(x,"band"). Then, compute NDVI by using a expression that uses the NIR (band 4) and R (band 3) attributes directly.

```{r}
tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
split(x,"band")

```

```{r}
ndvi = function(x) (x[4]-x[3])/(x[4]+x[3])
st_apply(x, c("x", "y"), ndvi)
```
## 4.4.2

Compute NDVI for the S2 image, using st_apply and an function ndvi = function(x) (x[4]-x[3])/(x[4]+x[3]). Plot the result, and write the result to a GeoTIFF. Explian the difference in runtime between plotting and writing.

```{r}
ndvi = function(x) (x[4]-x[3])/(x[4]+x[3])
y <- st_apply(x, c("x", "y"), ndvi)
y
```

Plotting and writting as GeoTIFF

```{r}
tf = tempfile(fileext=".tif")
write_stars(y, tf)
st_drivers("raster")
plot(y)
```

## 4.4.3

Use st_transform to transform the stars object read from L7_ETMs.tif to EPSG 4326. Print the object. Is this a regular grid? Plot the first band using arguments axes=TRUE and border=NA, and explain why this takes such a long time.

```{r}
tif = system.file("tif/L7_ETMs.tif", package = "stars")
x = read_stars(tif)
new = st_crs(4326)
y <- st_transform(x, new)
y

```

```{r}

plot(y, axes = TRUE, border =NA)

```

Toma mucho tiempo porque los datos de tif/L7_ETMs.tif son tipo raster y al aplicarle una transformación le estamos cambiando a otro sistema de coordenadas lo que genera perdida de datos.

## 4.4.4

Use st_warp to warp the L7_ETMs.tif object to EPSG 4326, and plot the resulting object with axes=TRUE. Why is the plot created much faster than after st_transform?

```{r}
tif <- system.file("tif/L7_ETMs.tif", package = "stars")
x <- read_stars(tif)
new_crs <- st_crs(4326)
y <- st_warp(x,crs = new_crs)
y
```

```{r}
plot(y, axes = TRUE)
```

Se tiene mejor eficiencia comparado a utilizar st_transform debido a que no se le modifica el tipo de referencia de coordenada.













